90a91
>     mesh_scale: float = 1.0  # Scaling factor for mesh size
93a95,97
>         assert 0.01 <= self.mesh_scale <= 10.0, (
>             "mesh_scale should be between 0.01 and 10.0"
>         )
273c277,283
<     geo.Append(["line", p2, q2], bc="sic/sio2", leftdomain=2, rightdomain=1, maxh=1)
---
>     geo.Append(
>         ["line", p2, q2],
>         bc="sic/sio2",
>         leftdomain=2,
>         rightdomain=1,
>         maxh=1 * geom.mesh_scale,
>     )
279c289,295
<     geo.Append(["line", origin, p2], bc="axis", leftdomain=2, rightdomain=0, maxh=0.5)
---
>     geo.Append(
>         ["line", origin, p2],
>         bc="axis",
>         leftdomain=2,
>         rightdomain=0,
>         maxh=0.5 * geom.mesh_scale,
>     )
284c300,306
<     geo.Append(["line", origin, tip1], bc="axis", leftdomain=0, rightdomain=3, maxh=0.5)
---
>     geo.Append(
>         ["line", origin, tip1],
>         bc="axis",
>         leftdomain=0,
>         rightdomain=3,
>         maxh=0.5 * geom.mesh_scale,
>     )
326c348
<     geo.SetDomainMaxH(2, 2)  # SiO2
---
>     geo.SetDomainMaxH(2, 2 * geom.mesh_scale)  # SiO2
345c367
<     V_tip: float,
---
>     V_tip_values: list[float],
348a371
>     maxerr=1e-11,
350c373,384
<     """Run the FEM simulation using NGSolve"""
---
>     """Run the FEM simulation using NGSolve for multiple V_tip values
> 
>     Optimizations:
>     - Mesh is created once and reused for all V_tip values
>     - V_tip values are sorted by absolute value for smooth convergence
>     - For i > 0, use previous solution as warm start and try direct Newton
>     - Fall back to partial homotopy if direct Newton fails
>     """
> 
>     # Sort and validate voltages
>     V_tip_sorted = sort_and_validate_voltages(V_tip_values)
>     logger.info(f"Processing V_tip values in order: {V_tip_sorted}")
351a386,387
>     # Create mesh once
>     logger.info("Creating mesh (this will be reused for all V_tip values)...")
367c403
<     # Define weak form
---
>     # Define weak form (once, will be reused)
382,390c418,440
<     # Set boundary conditions
<     u.Set(0, definedon=msh.Boundaries("ground"))  # Dirichlet BC at ground
<     u.Set(V_tip / V_c, definedon=msh.Boundaries("tip"))  # Dirichlet BC at tip
< 
<     # Compute initial solution with linear problem (Laplace equation)
<     _warm_start_with_linear_solve(fes, u, epsilon_r, V_tip, V_c, geom, msh)
< 
<     # Solve nonlinear problem with homotopy method
<     solve_with_homotopy(a, u, fes, msh, homotopy_charge, homotopy_sigma)
---
>     # Loop through V_tip values
>     for i, V_tip in enumerate(V_tip_sorted):
>         logger.info(f"{'=' * 60}")
>         logger.info(f"Solving for V_tip = {V_tip:.3f} V ({i + 1}/{len(V_tip_sorted)})")
>         logger.info(f"{'=' * 60}")
> 
>         # Set boundary conditions
>         u.Set(0, definedon=msh.Boundaries("ground"))  # Dirichlet BC at ground
>         u.Set(V_tip / V_c, definedon=msh.Boundaries("tip"))  # Dirichlet BC at tip
> 
>         if i == 0:
>             # First voltage: full procedure (linear warm-start + homotopy)
>             logger.info("First V_tip: performing full initialization...")
>             _warm_start_with_linear_solve(fes, u, epsilon_r, V_tip, V_c, geom, msh)
>             solve_with_homotopy(
>                 a, u, fes, msh, homotopy_charge, homotopy_sigma, maxerr=maxerr
>             )
>         else:
>             # Subsequent voltages: try direct Newton with fallback
>             logger.info("Using previous solution as warm start...")
>             solve_with_direct_newton(
>                 a, u, fes, msh, homotopy_charge, homotopy_sigma, maxerr=maxerr
>             )
392c442,445
<     save_results(msh, u, epsilon_r, V_c, Feenstra, out_dir)
---
>         # Save results in subdirectory
>         out_subdir = os.path.join(out_dir, f"V_tip_{V_tip:+.2f}V")
>         save_results(msh, u, epsilon_r, V_c, Feenstra, out_subdir)
>         logger.info(f"Results saved to {out_subdir}")
590c643
< def solve_with_homotopy(a, u, fes, msh, homotopy_charge, homotopy_sigma):
---
> def solve_with_homotopy(a, u, fes, msh, homotopy_charge, homotopy_sigma, maxerr=1e-11):
599c652,654
<     _solve_homotopy_stage(a, u, fes, msh, homotopy_charge, "Space Charge")
---
>     _solve_homotopy_stage(
>         a, u, fes, msh, homotopy_charge, "Space Charge", maxerr=maxerr
>     )
602c657,665
<     _solve_homotopy_stage(a, u, fes, msh, homotopy_sigma, "Interface Charge")
---
>     _solve_homotopy_stage(
>         a, u, fes, msh, homotopy_sigma, "Interface Charge", maxerr=maxerr
>     )
> 
> 
> def solve_with_direct_newton(
>     a, u, fes, msh, homotopy_charge, homotopy_sigma, fallback_theta=0.8, maxerr=1e-11
> ):
>     """Solve directly with Newton method (homotopy already at 1.0)
603a667,672
>     If Newton fails to converge, fall back to partial homotopy from fallback_theta to 1.0
>     """
>     logger.info("--- Attempting direct Newton solve (homotopy = 1.0) ---")
> 
>     homotopy_charge.Set(1.0)
>     homotopy_sigma.Set(1.0)
605c674,741
< def _solve_homotopy_stage(a, u, fes, msh, homotopy_param, stage_name: str):
---
>     freedofs = fes.FreeDofs()
>     freedofs &= ~fes.GetDofs(msh.Boundaries("ground"))
>     freedofs &= ~fes.GetDofs(msh.Boundaries("tip"))
> 
>     newton_kwargs = dict(
>         freedofs=freedofs,
>         maxit=100,
>         maxerr=maxerr,
>         inverse="sparsecholesky",
>         dampfactor=0.7,
>         printing=False,
>     )
> 
>     a.Assemble()
> 
>     try:
>         converged, iter = Newton(a, u, **newton_kwargs)
>         if converged < 0:
>             raise RuntimeError("Newton solver did not converge")
>         logger.info(f"  [Direct Newton] Converged in {iter} iterations.")
>         return
>     except Exception as exc:
>         logger.warning(f"  [Direct Newton] Failed: {exc}")
>         logger.info(
>             f"  Falling back to partial homotopy from θ={fallback_theta:.2f} to 1.0"
>         )
> 
>         # Fallback: run homotopy from fallback_theta to 1.0 for both parameters
>         backup = ng.GridFunction(fes)
>         backup.vec.data = u.vec
> 
>         # First do charge homotopy
>         homotopy_sigma.Set(fallback_theta)
>         theta = fallback_theta
>         step = 0.1
>         min_step = 1e-4
> 
>         while theta < 1.0 - 1e-12:
>             trial = min(1.0, theta + step)
>             homotopy_sigma.Set(trial)
>             a.Assemble()
> 
>             try:
>                 converged, iter = Newton(a, u, **newton_kwargs)
>                 if converged < 0:
>                     raise RuntimeError("Newton solver did not converge")
>                 theta = trial
>                 backup.vec.data = u.vec
>                 logger.info(
>                     f"  [Fallback Homotopy: θ={theta:.3f}] Converged in {iter} iterations."
>                 )
>                 if step < 0.5:
>                     step *= 1.5
>             except Exception as exc2:
>                 u.vec.data = backup.vec
>                 step *= 0.5
>                 logger.warning(
>                     f"  [Fallback Homotopy: θ→{trial:.3f}] Failed. Reducing step to {step:.4f}."
>                 )
>                 if step < min_step:
>                     raise RuntimeError(
>                         "Fallback homotopy failed: step size became too small."
>                     )
> 
> 
> def _solve_homotopy_stage(
>     a, u, fes, msh, homotopy_param, stage_name: str, maxerr=1e-11
> ):
622c758
<         maxerr=1e-11,
---
>         maxerr=maxerr,
763a900,931
> def parse_range_input(input_str: str) -> list[float]:
>     if ":" in input_str:
>         parts = input_str.split(":")
>         if len(parts) != 3:
>             raise ValueError("Range input must be in the format min:max:step")
>         min_val = float(parts[0])
>         max_val = float(parts[1])
>         step = float(parts[2])
>         return list(np.arange(min_val, max_val + step, step))
>     else:
>         return [float(input_str)]
> 
> 
> def sort_and_validate_voltages(V_tip_values: list[float]) -> list[float]:
>     """Sort voltages by absolute value and validate they don't cross zero"""
>     if len(V_tip_values) == 0:
>         raise ValueError("V_tip_values cannot be empty")
> 
>     # Check if range crosses zero
>     has_positive = any(v > 0 for v in V_tip_values)
>     has_negative = any(v < 0 for v in V_tip_values)
> 
>     if has_positive and has_negative:
>         raise ValueError(
>             f"V_tip range crosses zero (values: {V_tip_values}). "
>             "Please specify separate ranges for positive and negative voltages."
>         )
> 
>     # Sort by absolute value
>     return sorted(V_tip_values, key=abs)
> 
> 
769c937,940
<         "--V_tip", type=float, default=2.0, help="Tip voltage in Volts."
---
>         "--V_tip",
>         type=str,
>         default="2.0",
>         help="Tip voltages (single value or range min:max:step).",
809a981,989
>     parser.add_argument(
>         "--mesh_scale", type=float, default=1.0, help="Scaling factor for mesh size."
>     )
>     parser.add_argument(
>         "--maxerr",
>         type=float,
>         default=1e-11,
>         help="Maximum error tolerance for Newton solver.",
>     )
855c1035,1038
<         l_sio2=args.l_sio2, tip_radius=args.tip_radius, tip_height=args.tip_height
---
>         l_sio2=args.l_sio2,
>         tip_radius=args.tip_radius,
>         tip_height=args.tip_height,
>         mesh_scale=args.mesh_scale,
857a1041,1042
>     V_tip_values = parse_range_input(args.V_tip)
> 
863c1048
<             "V_tip": args.V_tip,
---
>             "V_tips": V_tip_values,
876c1061
<         V_tip=args.V_tip,
---
>         V_tip_values=V_tip_values,
879a1065
>         maxerr=args.maxerr,
